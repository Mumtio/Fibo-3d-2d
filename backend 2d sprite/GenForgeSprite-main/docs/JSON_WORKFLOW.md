# JSON-Native Agentic Workflow

This document describes the JSON-native workflow for automated sprite generation using FIBO structured prompts.

## Overview

The sprite generator uses a fully JSON-driven pipeline that transforms user prompts into game-ready sprite sheets through structured data transformations.

```
User Prompt → Canonical JSON → FIBO API → Canonical Image → Animation Expansion → Frame Generation → Sprite Assembly → Metadata Output
```

## Workflow Stages

### Stage 1: Input Processing

**Input:**
```json
{
    "prompt": "ninja warrior with katana",
    "preset": "anime_action",
    "animations": ["idle", "run", "attack"]
}
```

### Stage 2: Canonical Prompt Generation

The system generates a FIBO-compatible structured prompt:

```json
{
    "short_description": "A anime style game character reference sheet. Character: ninja warrior with katana. Front-facing, neutral pose.",
    "objects": [
        {
            "description": "ninja warrior with katana, standing in neutral T-pose or idle stance. Full body visible, front-facing, character reference sheet style.",
            "location": "center",
            "relative_size": "large, filling 85% of canvas height",
            "shape_and_color": "anime style character with clean defined outlines",
            "texture": "Clean, consistent coloring suitable for game sprites"
        }
    ],
    "background_setting": "Pure white or transparent background",
    "lighting": {
        "conditions": "Flat, even studio lighting",
        "direction": "Front lighting, no dramatic shadows"
    },
    "style_medium": "digital illustration",
    "artistic_style": "anime, game character design, sprite reference"
}
```

### Stage 3: Animation Prompt Expansion

Each animation type generates frame-specific prompts:

```json
{
    "idle": [
        {"frame": 0, "prompt": "ninja warrior with katana, idle pose, frame 0 of animation sequence"},
        {"frame": 1, "prompt": "ninja warrior with katana, idle pose, frame 1 of animation sequence"},
        {"frame": 2, "prompt": "ninja warrior with katana, idle pose, frame 2 of animation sequence"},
        {"frame": 3, "prompt": "ninja warrior with katana, idle pose, frame 3 of animation sequence"}
    ],
    "run": [
        {"frame": 0, "prompt": "ninja warrior with katana, run pose, frame 0 of animation sequence"},
        ...
    ],
    "attack": [
        {"frame": 0, "prompt": "ninja warrior with katana, attack pose, frame 0 of animation sequence"},
        ...
    ]
}
```

### Stage 4: Frame Generation

Each frame is generated by applying animation-specific transformations to the canonical image:

| Animation | Transformation |
|-----------|---------------|
| idle | Subtle scale breathing effect |
| run | Horizontal shift + rotation cycle |
| attack | Forward lean rotation |
| jump | Parabolic Y-offset arc |
| hurt | Knockback shift + red tint |
| death | Progressive rotation + fade |

### Stage 5: Output Assembly

**Sprite Sheets:**
- Individual animation sheets (horizontal strip)
- Combined master sheet (all animations stacked)

**Animated GIFs:**
- One GIF per animation
- Configurable frame duration

**Metadata JSON:**
```json
{
    "job_id": "uuid",
    "prompt": "ninja warrior with katana",
    "preset": "anime_action",
    "canvas_size": [512, 512],
    "frame_rate": 12,
    "animations": {
        "idle": {
            "frame_count": 4,
            "sprite_sheet": "outputs/{job_id}/idle_sheet.png",
            "gif": "outputs/{job_id}/idle.gif",
            "loop": true
        }
    },
    "phaser_config": {
        "frameWidth": 512,
        "frameHeight": 512,
        "animations": [...]
    },
    "unity_config": {
        "pixelsPerUnit": 100,
        "clips": [...]
    }
}
```

## Preset System

Presets define the style and animation parameters:

```json
{
    "name": "anime_action",
    "style": "anime",
    "canvas": [512, 512],
    "frame_rate": 12,
    "frame_duration": 83,
    "animations": {
        "idle": 4,
        "run": 6,
        "attack": 4,
        "jump": 3,
        "hurt": 2,
        "death": 4
    },
    "prompt_augmentation": {
        "prefix": "anime style, dynamic pose",
        "suffix": "vibrant colors, game sprite"
    }
}
```

## API Flow Diagram

```
┌─────────────────┐
│  POST /sprite/  │
│    generate     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Load Preset    │
│  (JSON config)  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Build Canonical │
│  Structured     │
│    Prompt       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  FIBO API Call  │
│  (or Mock)      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Expand Animation│
│    Prompts      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Generate Frames │
│ (Transform)     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Assemble Sheets │
│   + GIFs        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Generate JSON   │
│   Metadata      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Return Response │
│  with URLs      │
└─────────────────┘
```

## Game Engine Integration

### Phaser.js Example

```javascript
// In preload()
this.load.json('spriteData', '/outputs/{job_id}/metadata.json');
this.load.spritesheet('character', '/outputs/{job_id}/combined_sheet.png', {
    frameWidth: 512,
    frameHeight: 512
});

// In create()
const data = this.cache.json.get('spriteData');
data.phaser_config.animations.forEach(anim => {
    this.anims.create({
        key: anim.key,
        frames: this.anims.generateFrameNumbers('character', anim.frames),
        frameRate: anim.frameRate,
        repeat: anim.repeat
    });
});

// Play animation
this.player.play('idle');
```

### Unity Integration

1. Import `combined_sheet.png` as Sprite (Multiple)
2. Use Sprite Editor to slice based on `unity_config.frameSize`
3. Create Animation Clips using `unity_config.clips` data
4. Set sample rate from `unity_config.clips[].sampleRate`

### Godot Integration

```gdscript
# Load metadata
var file = File.new()
file.open("res://sprites/metadata.json", File.READ)
var metadata = JSON.parse(file.get_as_text()).result
file.close()

# Setup AnimatedSprite
var sprite = AnimatedSprite.new()
for anim_name in metadata.animations:
    var anim = metadata.animations[anim_name]
    sprite.frames.add_animation(anim_name)
    for i in range(anim.frame_count):
        var frame = load("res://sprites/" + anim_name + "/frame_%02d.png" % i)
        sprite.frames.add_frame(anim_name, frame)
    sprite.frames.set_animation_speed(anim_name, metadata.frame_rate)
    sprite.frames.set_animation_loop(anim_name, anim.loop)
```

## Benefits of JSON-Native Approach

1. **Reproducibility**: Same input JSON always produces same output
2. **Debuggability**: Each stage outputs inspectable JSON
3. **Extensibility**: Add new presets/animations via JSON config
4. **Integration**: Direct compatibility with game engines
5. **Automation**: Easy to batch process multiple characters
6. **Version Control**: JSON configs can be tracked in git

## Custom Workflow Example

Create a batch processing script:

```python
import requests

characters = [
    {"prompt": "knight with shield", "preset": "pixel_art_rpg"},
    {"prompt": "wizard with staff", "preset": "pixel_art_rpg"},
    {"prompt": "archer with bow", "preset": "pixel_art_rpg"}
]

for char in characters:
    response = requests.post(
        "http://localhost:5000/sprite/generate",
        json=char
    )
    result = response.json()
    print(f"Generated: {result['job_id']}")
```

This JSON-native workflow enables fully automated, reproducible sprite generation suitable for game development pipelines.
